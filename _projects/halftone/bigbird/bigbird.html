---
layout: page
title: Big Bird
menu: main
permalink: /projects/halftone/bigbird
---

<script>
  const domTarget = document.currentScript.parentElement;
  const attach = (node) => {
    document.currentScript.parentElement.appendChild(node);
  };

  const resize = (canvas, width, height) => {
    canvas.width = width;
    canvas.height = height;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
  };

  const createCanvas = (width, height) => {
    const canvas = document.createElement("canvas");
    resize(canvas, width, height);
    return canvas;
  };

  const map = (value, minA, maxA, minB, maxB) => {
    return ((value - minA) / (maxA - minA)) * (maxB - minB) + minB;
  };

  const rotatePointAboutPosition = ([x, y], [rotX, rotY], angle) => {
    return [
      (x - rotX) * Math.cos(angle) - (y - rotY) * Math.sin(angle) + rotX,
      (x - rotX) * Math.sin(angle) + (y - rotY) * Math.cos(angle) + rotY,
    ];
  };

  const positionToDataIndex = (x, y, width) => {
    width = width || WIDTH;
    // data is arranged as [R, G, B, A, R, G, B, A, ...]
    return (y * width + x) * 4;
  };

  const halftone = ({
    angle,
    dotSize,
    dotResolution,
    targetCtx,
    sourceCtx,
    width,
    height,
    color,
    layer,
  }) => {
    const sourceImageData = sourceCtx.getImageData(0, 0, width, height);
    angle = (angle * Math.PI) / 180;
    targetCtx.fillStyle = "white";
    layer || targetCtx.fillRect(0, 0, width, height);
    targetCtx.fillStyle = color || "black";
    // get the four corners of the screen
    const tl = [0, 0];
    const tr = [width, 0];
    const br = [width, height];
    const bl = [0, height];
    // rotate the screen, then find the minimum and maximum of the values.
    const boundaries = [tl, br, tr, bl].map(([x, y]) => {
      return rotatePointAboutPosition([x, y], [width / 2, height / 2], angle);
    });
    const minX = Math.min(...boundaries.map((point) => point[0])) | 0;
    const minY = Math.min(...boundaries.map((point) => point[1])) | 0;
    const maxY = Math.max(...boundaries.map((point) => point[1])) | 0;
    const maxX = Math.max(...boundaries.map((point) => point[0])) | 0;

    for (let y = minY; y < maxY; y += dotResolution) {
      for (let x = minX; x < maxX; x += dotResolution) {
        let [rotatedX, rotatedY] = rotatePointAboutPosition(
          [x, y],
          [width / 2, height / 2],
          angle
        );

        if (
          rotatedX < 0 ||
          rotatedY < 0 ||
          rotatedX > width ||
          rotatedY > height
        ) {
          continue;
        }
        const index = positionToDataIndex(
          Math.floor(rotatedX),
          Math.floor(rotatedY),
          width
        );
        // we're always operating on grayscale images, so just grab the value from
        // the red channel.
        const value = sourceImageData.data[index];
        const alpha = sourceImageData.data[index + 3];
        if (alpha) {
          const circleRadius = map(value, 0, 255, dotSize / 2, 0);
          targetCtx.beginPath();
          targetCtx.arc(rotatedX, rotatedY, circleRadius, 0, Math.PI * 2);
          targetCtx.closePath();
          targetCtx.fill();
        }
      }
    }
  };
  const birdImage = new Image();
  birdImage.src = "/projects/halftone/bigbirds.jpg";
  const birdCanvas = createCanvas(1, 1);
  const birdContext = birdCanvas.getContext("2d");

  const compositeBirdCanvas = createCanvas(1, 1);
  attach(compositeBirdCanvas);
  const compositeBirdContext = compositeBirdCanvas.getContext("2d");

  const birdReady = new Promise((resolve) => {
    birdImage.onload = () => {
      const aspectRatio = birdImage.height / birdImage.width;
      birdImage.width = Math.min(birdImage.width, window.screen.width - 50);
      birdImage.height = birdImage.width * aspectRatio;

      resize(birdCanvas, birdImage.width, birdImage.height);
      resize(compositeBirdCanvas, birdImage.width, birdImage.height);
      birdContext.drawImage(birdImage, 0, 0, birdImage.width, birdImage.height);
      halftoneBird();
    };
  });

  const birdAngles = {
    yellow: 0,
    cyan: 15,
    key: 75,
    magenta: 45,
  };

  const halftoneBird = () => {
    const birdData = birdContext.getImageData(
      0,
      0,
      birdCanvas.width,
      birdCanvas.height
    );
    compositeBirdContext.fillStyle = "white";
    compositeBirdContext.fillRect(0, 0, birdCanvas.width, birdCanvas.height);

    const inMemoryCanvas = createCanvas(birdCanvas.width, birdCanvas.height);
    const grayscaleCtx = inMemoryCanvas.getContext("2d");
    const grayscaleImageData = grayscaleCtx.getImageData(
      0,
      0,
      inMemoryCanvas.width,
      inMemoryCanvas.height
    );
    [
      { angle: birdAngles.yellow, color: "yellow", channel: 2 },
      {
        angle: birdAngles.magenta,
        color: "rgba(255, 0, 255, 0.6)",
        channel: 1,
      },
      { angle: birdAngles.cyan, color: "rgba(0, 255, 255, 0.6)", channel: 0 },
      { angle: birdAngles.key, color: "black", key: true },
    ].forEach(({ angle, color, channel, key }) => {
      for (let y = 0; y < birdCanvas.height; y++) {
        for (let x = 0; x < birdCanvas.width; x++) {
          const index = positionToDataIndex(x, y, birdCanvas.width);
          const [r, g, b, a] = [
            birdData.data[index + 0],
            birdData.data[index + 1],
            birdData.data[index + 2],
            birdData.data[index + 3],
          ];
          const keyValue = 255 - Math.max(r, g, b);
          if (key) {
            grayscaleImageData.data[index + 0] = 255 - keyValue;
            grayscaleImageData.data[index + 1] = 255 - keyValue;
            grayscaleImageData.data[index + 2] = 255 - keyValue;
            grayscaleImageData.data[index + 3] = 255;
          } else {
            const complement = 255 - birdData.data[index + channel];
            grayscaleImageData.data[index + 0] = 255 - (complement - keyValue);
            grayscaleImageData.data[index + 1] = 255 - (complement - keyValue);
            grayscaleImageData.data[index + 2] = 255 - (complement - keyValue);
            grayscaleImageData.data[index + 3] = 255;
          }
        }
      }
      grayscaleCtx.putImageData(grayscaleImageData, 0, 0);
      halftone({
        angle: angle,
        dotSize: 3,
        dotResolution: 2,
        targetCtx: compositeBirdContext,
        sourceCtx: grayscaleCtx,
        width: birdCanvas.width,
        height: birdCanvas.height,
        color: color,
        layer: true,
      });
    });
  };
</script>
